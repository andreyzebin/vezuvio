/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import io.github.zebin.javabash.frontend.FunnyTerminal;
import io.github.zebin.javabash.process.TerminalProcess;
import io.github.zebin.javabash.sandbox.BashUtils;
import io.github.zebin.javabash.sandbox.FileManager;
import io.github.zebin.javabash.sandbox.PosixPath;
import io.github.zebin.javabash.sandbox.WorkingDirectory;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

@Slf4j
public class App {


    public static void main(String[] args) {
        FunnyTerminal terminal = new FunnyTerminal(
                new TerminalProcess(BashUtils.runShellForOs(Runtime.getRuntime()))
        );
        FileManager fm = new FileManager(terminal);
        fm.goUp(); // .../.tray/repository
        fm.goUp(); // .../.tray
        PosixPath home = fm.getCurrent();
        PosixPath resources = fm.makeDir(PosixPath.ofPosix("resources"));
        WorkingDirectory wd = new WorkingDirectory(fm);

        String os = terminal.eval("echo $(uname)");
        log.debug("logger.root.level={}", System.getProperty("logger.root.level"));

        if (Arrays.equals(args, List.of("list", "leafs").toArray(new String[]{}))) {

        } else if (Stream.of(
                        "list",
                        "branches",
                        ).map(StringMatcher::exact).toList()
                .equals(Arrays.stream(args).map(StringMatcher::escape).toList())) {

        } else if (test("set", /* key */ "*", /* value */ "*")) {

        } else if (Arrays.equals(args, List.of("shellenv").toArray(new String[]{}))) {
            terminal.eval(String.format("export TRAY_HOME=\"%s\"", home));
        } else if (
                Arrays.equals(args, List.of("--version").toArray(new String[]{})) ||
                        Arrays.equals(args, List.of("-v").toArray(new String[]{}))
        ) {
            log.info("tray {}", System.getProperty("version"));
        }

    }

    private static boolean test(arg1, String[]..args) {
        return Stream.of(arg1, args
                        /* value */
                ).map(StringMatcher::exact).toList()
                .equals(Arrays.stream(args).map(StringMatcher::escape).toList());
    }

    public static class StringMatcher {
        public static final StringMatcher ANY = new StringMatcher(true, "*");
        private final boolean isWild;
        private final String template;

        private StringMatcher(boolean isWild, String template) {
            this.isWild = isWild;
            this.template = template;
        }

        public static StringMatcher exact(String s) {
            if (s.equals("*")) {
                return ANY;
            }
            return new StringMatcher(false, s);
        }

        public static StringMatcher escape(String s) {
            return new StringMatcher(false, s);
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) return false;
            StringMatcher that = (StringMatcher) o;
            if (isWild || that.isWild) {
                return true;
            }
            return Objects.equals(template, that.template);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode("*");
        }
    }
}
