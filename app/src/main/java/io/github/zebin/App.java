/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.zebin;

import io.github.andreyzebin.gitSql.config.ConfigTree;
import io.github.andreyzebin.gitSql.config.ConfigVersions;
import io.github.andreyzebin.gitSql.git.LocalSource;
import io.github.zebin.javabash.frontend.FunnyTerminal;
import io.github.zebin.javabash.process.TerminalProcess;
import io.github.zebin.javabash.sandbox.BashUtils;
import io.github.zebin.javabash.sandbox.DirectoryTree;
import io.github.zebin.javabash.sandbox.FileManager;
import io.github.zebin.javabash.sandbox.PosixPath;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.function.Consumer;
import java.util.stream.Stream;

@Slf4j
public class App {
    private FunnyTerminal terminal;
    private FileManager fm;
    private final Consumer<String> stdOUT;
    private final Consumer<String> stdERR;

    public App(Consumer<String> stdOUT, Consumer<String> stdERR) {
        this.stdOUT = stdOUT;
        this.stdERR = stdERR;
    }

    public static void main(String[] args) {
        new App(System.out::println, System.err::println).run(args);
    }

    public void run(String[] args) {
        terminal = new FunnyTerminal(
                new TerminalProcess(BashUtils.runShellForOs(Runtime.getRuntime()))
        );
        fm = new FileManager(terminal);
        // fm.goUp(); // .../.vezuvio/repository
        // fm.goUp(); // .../.vezuvio

        String resourcesLocation = System.getProperty("VEZUVIO_resources_path");
        String repoLocation = System.getProperty("VEZUVIO_repository_location");

        fm.makeDir(PosixPath.ofPosix(resourcesLocation));
        fm.go(PosixPath.ofPosix(resourcesLocation));
        PosixPath home = fm.getCurrent();
        PosixPath resources = fm.makeDir(PosixPath.ofPosix("resources"));
        PosixPath mockRepo = PosixPath.ofPosix(repoLocation);

        try (LocalSource src = new LocalSource(mockRepo.toPath(), terminal)) {
            fm.go(mockRepo);
            DirectoryTree dt = src.getDirectory();
            ConfigTree ct = new ConfigTree(dt);
            ConfigVersions cf = new ConfigVersions(src, dt, ct);

            String os = terminal.eval("echo $(uname)");
            log.debug("logger.root.level={}", System.getProperty("logger.root.level"));

            if (test(args, "list", "leafs")) {
                ct.getLeafs()
                        .map(PosixPath::toString)
                        .forEach(stdOUT);
            } else if (test(args, "list", "branches")) {
                src.branch().ifPresent(stdOUT);

            } else if (test(args, "list", "versions")) {
                cf.listVersions()
                        .map(ConfigVersions.PropertiesVersion::getVersionHash)
                        .forEach(stdOUT);

            } else if (test(args, "list", "properties")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                ct.getPropertyKeys(PosixPath.ofPosix(leaf)).forEach(stdOUT);
            } else if (test(args, "use", /* key */ "branch", /* value */ "*")) {
                setCurrent(args[2], resources, "branch");

                log.info("Branch {} has been set as current", args[2]);
            } else if (test(args, "use", /* key */ "leaf", /* value */ "*")) {
                setCurrent(args[2], resources, "leaf");

                log.info("Leaf {} has been set as current", args[2]);
            } else if (test(args, "use", "lock")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                ConfigVersions.LeafLock leafLock = cf.tryLock(PosixPath.ofPosix(leaf));
                setCurrent(leafLock.getLockId(), resources, "lock");

                log.info("Lock has been acquired id = {}, ts = {}",
                        leafLock.getLockId(), leafLock.getObtainedEpochSec());
            } else if (test(args, "use", "version", "*")) {

                setCurrent(args[2], resources, "version");
            } else if (test(args, "unuse", "version")) {

                unSet(resources, "version");
            } else if (test(args, "unuse", "lock")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                String lockId = getCurrent(resources, "lock");
                cf.unLock(PosixPath.ofPosix(leaf), lockId);
                unSet(resources, "lock");
                log.info("Lock id = {} has been released", lockId);
            } else if (test(args, "commit", "offset",/* newHash */ "*")) {
                PosixPath leaf = PosixPath.ofPosix(getCurrent(resources, "leaf"));

                String ver = getCurrent(resources, "version");

                if (ver != null) {
                    log.error("Must not set version under version use. Please unuse version first...");
                    return;
                }

                String lockId = getCurrent(resources, "lock");
                if (lockId == null) {
                    log.error("Please acquire lock first");
                    return;
                }

                cf.setVersion(leaf, args[2], lockId);
            } else if (test(args, "set", "property",  /* key */ "*", /* value */ "*")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                String ver = getCurrent(resources, "version");
                if (ver != null) {
                    log.error("Must not set property under version use. Please unuse version first...");
                    return;
                }

                ct.setProperty(PosixPath.ofPosix(leaf), args[2], args[3]);
                log.info("Property {}#{} has been set", leaf, args[2]);
            } else if (test(args, "get", "property", /* key */ "*")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                String ver = getCurrent(resources, "version");
                if (ver != null) {
                    log.debug("Using version {}", ver);
                    stdOUT.accept(cf.getProperty(ver, PosixPath.ofPosix(leaf), args[2]));
                    return;
                }

                stdOUT.accept(ct.getProperty(PosixPath.ofPosix(leaf), args[2]));
            } else if (test(args, "get", "offset")) {
                String leaf = getCurrent(resources, "leaf");
                if (missingLeaf(leaf)) return;

                stdOUT.accept(cf.getVersion(PosixPath.ofPosix(leaf)).getVersionHash());
            } else if (test(args, "shellenv")) {
                terminal.eval(String.format("export VEZUVIO_HOME=\"%s\"", home));
            } else if (test(args, "--version")) {
                stdOUT.accept(System.getProperty("version"));
            }
        }
    }

    private static boolean missingLeaf(String leaf) {
        if (leaf == null) {
            log.error("Cannot list properties: Leaf has not been chosen yet. Please run 'use leaf [leaf]' first");
            return true;
        }
        return false;
    }

    private void setCurrent(String value, PosixPath resources, String domain) {
        fm.go(resources);
        PosixPath audioPrefix = PosixPath.ofPosix(domain);
        fm.remove(audioPrefix.climb("current"));
        terminal.eval(
                String.format(
                        "ln -s %s %s",
                        fm.makeDir(audioPrefix.climb(PosixPath.ofPosix(value))),
                        audioPrefix.climb("current")
                )
        );
    }

    private void unSet(PosixPath resources, String domain) {
        fm.go(resources);
        PosixPath audioPrefix = PosixPath.ofPosix(domain);
        fm.remove(audioPrefix.climb("current"));
    }

    private String getCurrent(PosixPath resources, String domain) {
        PosixPath currentPath = resources.climb(domain, "current");
        if (!fm.exists(currentPath)) {
            return null;
        }
        PosixPath audioDevice = PosixPath.ofPosix(
                terminal.eval(String.format("readlink %s", currentPath))
        );

        return audioDevice.relativize(resources.climb(domain)).toString();
    }

    private boolean test(String[] args, String arg1, String... argsOther) {
        return Stream.concat(Stream.of(arg1), Stream.of(argsOther))
                .map(ArgsMatcher::exact)
                .toList()
                .equals(Arrays.stream(args).map(ArgsMatcher::escape).toList());
    }

}
