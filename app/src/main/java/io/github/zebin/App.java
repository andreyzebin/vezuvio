/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.zebin;

import io.github.andreyzebin.gitSql.FileSystemUtils;
import io.github.andreyzebin.gitSql.cache.FileManagerCacheProxy;
import io.github.andreyzebin.gitSql.cache.GitFsCacheProxy;
import io.github.andreyzebin.gitSql.config.ConfigHistory;
import io.github.andreyzebin.gitSql.config.ConfigTree;
import io.github.andreyzebin.gitSql.config.ConfigVersions;
import io.github.andreyzebin.gitSql.config.RequestTree;
import io.github.andreyzebin.gitSql.git.GitAuth;
import io.github.andreyzebin.gitSql.git.GitConfigurations;
import io.github.andreyzebin.gitSql.git.GitFs;
import io.github.andreyzebin.gitSql.git.RemoteOrigin;
import io.github.zebin.javabash.frontend.FunnyTerminal;
import io.github.zebin.javabash.process.TerminalProcess;
import io.github.zebin.javabash.process.TextTerminal;
import io.github.zebin.javabash.sandbox.*;
import lombok.extern.slf4j.Slf4j;

import java.io.InputStreamReader;
import java.net.URLEncoder;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
public class App {
    public static final String IO_GITHUB_VEZUVIO = "io.github.vezuvio";

    public static final String ORIGINS_CURRENT = "origins.current";
    public static final String CREDENTIALS_CURRENT = "credentials.current";
    public static final String BRANCHES_CURRENT = "branches.current";
    public static final String CHANGES_BASE = "changes.base";
    public static final String LEAFS_CURRENT = "leafs.current";

    public static final String CHANGES_API = "changes";
    public static final String LIST_METHOD = "list|ls";
    public static final String EXPLODE_METHOD = "explode|exp";
    private FileManager fm;
    private final Consumer<String> stdOUT;
    private final Consumer<String> stdERR;
    private final Configurations conf;

    public App(Consumer<String> stdOUT, Consumer<String> stdERR, Configurations conf) {
        this.stdOUT = stdOUT;
        this.stdERR = stdERR;
        this.conf = conf;
    }

    public static String fixWinPath(String corruptWinPath) {
        String[] split = corruptWinPath.split(":");
        boolean hasDisk = split.length > 1;
        // boolean isAbsolute = hasDisk;

        if (hasDisk) {
            String disk = split[0];
            String path = split[1];
            return "/" + disk.toLowerCase() + path;
        } else {
            return corruptWinPath;
        }
    }

    public static void main(String[] args) {
        TextTerminal terminal = new FunnyTerminal(
                new TerminalProcess(BashUtils.runShellForOs(Runtime.getRuntime()))
        );
        AllFileManager fm = new FileManager(terminal);

        fm = FileManagerCacheProxy.cachedProxy(fm, new AtomicReference<>("kk"));
        String workingDirOverride = System.getProperty(IO_GITHUB_VEZUVIO + ".workingDirectory");
        PosixPath wd;
        if (workingDirOverride != null) {
            log.info("Working directory is set via system property");
            wd = fm.go(PosixPath.ofPosix(fixWinPath(workingDirOverride)));
        } else {
            log.info("Working directory is set from java process");
            wd = fm.getCurrent();
        }

        boolean workDirConfExist = fm.dirExists(wd.climb(".vezuvio"));
        Configurations cnf = new Configurations(wd, terminal, workDirConfExist ?
                VirtualDirectoryTree.WORKDIR_LEVEL_CONF :
                VirtualDirectoryTree.USER_LEVEL_CONF, fm);

        log.info("Configuration top is {}", cnf.getConfLevel());
        App app = new App(System.out::println, System.err::println, cnf);

        if (test(args, "daemon")) {
            // TODO Daemon
            new Daemon(app);
            return;
        }

        app.run(args);
    }

    public static <T> Stream<T> lastElements(Stream<T> l, int n) {
        LinkedList<T> ll = new LinkedList<>();

        l.forEach(el -> {
            ll.addFirst(el);

            if (ll.size() > n) {
                ll.removeLast();
            }
        });

        return ll.stream();
    }

    public void run(String[] args) {
        TextTerminal terminal = conf.getTerm();
        fm = new FileManager(terminal);

        if (test(args, "origins", "use", anyWord())) {
            setConf(ORIGINS_CURRENT, args[2]);
        } else if (test(args, "credentials", "use", anyWord())) {
            setConf(CREDENTIALS_CURRENT, args[2]);
        } else if (test(args, "leafs", "use", anyWord())) {
            setConf(LEAFS_CURRENT, args[2]);
        } else if (test(args, "leafs", "drop")) {
            conf.getConf().deleteProperty(conf.getConfLevel(), IO_GITHUB_VEZUVIO + "." + LEAFS_CURRENT);
        } else if (test(args, "leafs", LIST_METHOD)) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                rt.getBranch(cBranch).getLeafs().map(PosixPath::toString).forEach(stdOUT);
            });
        } else if (startsWith(args, CHANGES_API)) {
            changesAPI(args);
        } else if (startsWith(args, "branches")) {
            branchesAPI(args);
        } else if (test(args, "leafs", "which")) {
            stdOUT.accept(getConf(LEAFS_CURRENT));
        } else if (test(args, "credentials", "which")) {
            stdOUT.accept(getConf(CREDENTIALS_CURRENT));
        } else if (test(args, "origins", "which")) {
            stdOUT.accept(getConf(ORIGINS_CURRENT));
        } else if (startsWith(args, "properties")) {
            propertiesAPI(args);
        } else if (test(args, "--version")) {
            stdOUT.accept(System.getProperty(IO_GITHUB_VEZUVIO + ".version"));
        } else if (test(args, "--help")) {
            printHelp();
        } else if (test(args, "--system.properties")) {
            System.getProperties()
                    .forEach((key, value) ->
                            stdOUT.accept(String.format("%s=%s", key, value)));
        } else {
            wrongArgs(args);
        }
    }

    private static String anyWord() {
        return "*";
    }

    private void propertiesAPI(String[] args1) {
        boolean useLeafFilter = Arrays.stream(args1).toList().contains("--filter");
        String cLeaf = getConf(LEAFS_CURRENT);
        String[] args = Arrays.stream(args1).toList().stream().filter(cArg -> !cArg.equals("--filter"))
                .toArray(String[]::new);

        if (test(args, "properties", LIST_METHOD, "--format=lSPkEQv") ||
                test(args, "properties", LIST_METHOD)) {
            String cBranch = getConf(BRANCHES_CURRENT);
            // TODO show only current leaf
            withRequestTree(rt -> {
                ConfigVersions branch = rt.getBranch(cBranch);
                branch.getProperties(branch.topVersion().get().getVersionHash())
                        .forEach((k, v) -> stdOUT.accept(k.getKey() + " " + k.getValue() + "=" + v));
            });
        } else if (test(args, "properties", EXPLODE_METHOD, "--format=lSPkEQv") ||
                test(args, "properties", EXPLODE_METHOD)) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                ConfigVersions branch = rt.getBranch(cBranch);
                branch.getExplodedState(branch.topVersion().get().getVersionHash())
                        .entrySet()
                        .stream()
                        .filter(cEntr -> cEntr.getKey().getKey().toString().equals(cLeaf) || !useLeafFilter)
                        .forEach((key) -> stdOUT.accept(key.getKey().getKey() + " " + key.getKey().getValue() + "=" + key.getValue()));
            });
        } else if (test(args, "properties", EXPLODE_METHOD, "--format=html")) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                ConfigVersions branch = rt.getBranch(cBranch);
                StringBuffer bw = new StringBuffer();

                Comparator<Map.Entry<Map.Entry<PosixPath, String>, String>> comparator = Comparator
                        .comparing(ff -> ff.getKey().getKey().toString());
                toHTMlState(
                        branch.getExplodedState(branch.topVersion().get().getVersionHash()),
                        comparator,
                        bw,
                        cBranch,
                        (key) -> bw.append(
                                String.format("<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n",
                                        key.getKey().getKey(), key.getKey().getValue(), key.getValue())),
                        cEntr -> cEntr.getKey().getKey().toString().equals(cLeaf) || !useLeafFilter,
                        "presentation/web/index.html", "baseBranch");
            });
        } else if (test(args, "properties", anyWord(), "get")) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                stdOUT.accept(rt.getBranch(cBranch).getEffectiveProperty(PosixPath.ofPosix(cLeaf), args[1]));
            });
        } else if (test(args, "properties", anyWord(), "set", anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                ConfigVersions cBr = rt.getBranch(cBranch);
                cBr.setProperty(PosixPath.ofPosix(cLeaf), args[1], args[3]);
                cBr.commit();
                cBr.push();
            });
        } else if (test(args, "properties", anyWord(), "delete")) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> {
                ConfigVersions cBr = rt.getBranch(cBranch);
                cBr.deleteProperty(PosixPath.ofPosix(cLeaf), args[1]);
                cBr.commit();
                cBr.push();
            });
        } else {
            wrongArgs(args);
        }
    }

    private <T, V> void toHTMlState(
            Map<T, V> state,
            Comparator<Map.Entry<T, V>> rowComparator,
            StringBuffer bw,
            String cBranch,
            Consumer<Map.Entry<T, V>> rowRenderer,
            Predicate<Map.Entry<T, V>> rowFilter, String templateAddress, String baseBranch) {
        state
                .entrySet()
                .stream()
                .filter(rowFilter)
                .sorted(rowComparator)
                .forEach(rowRenderer);

        InputStreamReader template = new InputStreamReader(
                getClass().getClassLoader().getResourceAsStream(templateAddress));

        String html = FileSystemUtils.loadFile(template).replace("$props", bw)
                .replace("$requestBranch", cBranch)
                .replace("$baseBranch", baseBranch);
        html.lines().forEach(stdOUT);
    }

    private void branchesAPI(String[] args) {
        if (test(args, "branches", "which")) {
            stdOUT.accept(getConf(BRANCHES_CURRENT));
        } else if (test(args, "branches", LIST_METHOD)) {
            withRequestTree(rt -> {
                rt.listBranches().forEach(stdOUT::accept);
            });
        } else if (test(args, "branches", "prune")) {
            fm.remove(conf.getVezuvioLocalHome().climb("tmp"));
        } else if (test(args, "branches", "use", anyWord())) {
            setConf(BRANCHES_CURRENT, args[2]);
        } else if (test(args, "branches", "fork", anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> rt.createBranch(cBranch, args[2]));
            setConf(BRANCHES_CURRENT, args[2]);
        } else {
            wrongArgs(args);
        }
    }

    private void changesAPI(String[] args) {
        if (test(args, CHANGES_API, EXPLODE_METHOD)) {
            String cBranch = getConf(BRANCHES_CURRENT);
            String baseBranch = Optional.ofNullable(getConf(CHANGES_BASE)).orElse("master");

            changesExplodeAPI(cBranch, baseBranch);
        } else if (test(args, CHANGES_API, "use", "base", anyWord())) {
            setConf(CHANGES_BASE, args[3]);
        } else if (test(args, CHANGES_API, "which", "base")) {
            stdOUT.accept(getConf(CHANGES_BASE));
        } else if (test(args, CHANGES_API, EXPLODE_METHOD, anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            changesExplodeAPI(cBranch, args[2]);
        } else if (test(args, CHANGES_API, LIST_METHOD)) {
            String cBranch = getConf(BRANCHES_CURRENT);
            String baseBranch = Optional.ofNullable(getConf(CHANGES_BASE)).orElse("master");

            changesListAPI(cBranch, baseBranch);
        } else if (test(args, CHANGES_API, LIST_METHOD, "--format=html")) {
            String cBranch = getConf(BRANCHES_CURRENT);
            String baseBranch = Optional.ofNullable(getConf(CHANGES_BASE)).orElse("master");

            withRequestTree(rt -> {
                ConfigVersions branch = rt.getBranch(cBranch);
                StringBuffer bw = new StringBuffer();
                Comparator<Map.Entry<Map.Entry<PosixPath, String>, ConfigHistory.Change<String>>> comparator = Comparator
                        .comparing(ff -> ff.getKey().getKey().toString());
                toHTMlState(
                        branch.getChanges(
                                branch.getOffset(baseBranch),
                                branch.topVersion().get().getVersionHash()),
                        comparator,
                        bw,
                        cBranch,
                        (key) -> bw.append(
                                String.format("<tr><td>%s</td><td>%s</td><td>%s->%s</td></tr>\n",
                                        key.getKey().getKey().toString(),
                                        key.getKey().getValue(),
                                        key.getValue().getBefore(),
                                        key.getValue().getAfter())),
                        cEntr -> true,
                        "presentation/web/changes.html",
                        baseBranch);
            });
        } else if (test(args, CHANGES_API, LIST_METHOD, anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            changesListAPI(cBranch, args[2]);
        } else if (test(args, CHANGES_API, "merge", anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> rt.getBranch(cBranch).merge(args[2]));
        } else if (test(args, CHANGES_API, "merge")) {
            String cBranch = getConf(BRANCHES_CURRENT);
            String baseBranch = Optional.ofNullable(getConf(CHANGES_BASE)).orElse("master");

            withRequestTree(rt -> rt.getBranch(cBranch).merge(baseBranch));
        } else if (test(args, CHANGES_API, "rebase", anyWord(), anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> rt.getBranch(cBranch).rebase(args[2], args[3]));
        } else if (test(args, CHANGES_API, "rebase", anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);
            String baseBranch = Optional.ofNullable(getConf(CHANGES_BASE)).orElse("master");

            withRequestTree(rt -> rt.getBranch(cBranch).rebase(baseBranch, args[2]));
            setConf(CHANGES_BASE, args[2]);
        } else if (test(args, CHANGES_API, "copy", anyWord())) {
            String cBranch = getConf(BRANCHES_CURRENT);

            withRequestTree(rt -> rt.createBranch(cBranch, args[2]));
        } else {
            wrongArgs(args);
        }
    }

    private void changesExplodeAPI(String cBranch, String base) {
        withRequestTree(rt -> {
            ConfigVersions cBr = rt.getBranch(cBranch);
            cBr.getExplodedChanges(cBr.getOffset(base), cBr.topVersion().get().getVersionHash())
                    .entrySet()
                    .stream()
                    .map(ce -> String.format("%s %s: %s -> %s",
                            ce.getKey().getKey(),
                            ce.getKey().getValue(),
                            ce.getValue().getBefore(),
                            ce.getValue().getAfter()))
                    .forEach(stdOUT);
        });
    }

    private void changesListAPI(String cBranch, String base) {
        withRequestTree(rt -> {
            ConfigVersions cBr = rt.getBranch(cBranch);
            cBr.getChanges(cBr.getOffset(base), cBr.topVersion().get().getVersionHash())
                    .entrySet()
                    .stream()
                    .map(ce -> String.format("%s %s: %s -> %s",
                            ce.getKey().getKey(),
                            ce.getKey().getValue(),
                            ce.getValue().getBefore(),
                            ce.getValue().getAfter()))
                    .forEach(stdOUT);
        });
    }

    private void wrongArgs(String[] args) {
        try {
            throw new IllegalArgumentException("Wrong args: " + Stream.of(args)
                    .map(cArg -> "<" + cArg + ">").collect(Collectors.joining(";")));
        } catch (RuntimeException e) {
            stdOUT.accept("Wrong arguments!");
            printHelp();

            throw e;
        }
    }

    private void printHelp() {
        stdOUT.accept("USAGE: vezuvio [--question]");
        stdOUT.accept("       OR");
        stdOUT.accept("       vezuvio [collection] ([item_id] OR nothing) [method] ([data] OR nothing)");
    }

    private void setConf(String originsCurrent, String value) {
        conf.getConf().setProperty(conf.getConfLevel(), IO_GITHUB_VEZUVIO + "." + originsCurrent, value);
    }

    private String getConf(String prop) {
        return conf.getConf().getEffectiveProperty(conf.getConfLevel(), IO_GITHUB_VEZUVIO + "." + prop);
    }

    public static boolean test(String[] args, String arg1, String... argsOther) {
        List<ArgsMatcher> expectedArgs = Stream.concat(Stream.of(arg1), Stream.of(argsOther))
                .map(ArgsMatcher::exact)
                .toList();
        List<ArgsMatcher> testArgs = Arrays.stream(args).map(ArgsMatcher::escape).toList();
        return expectedArgs.equals(testArgs);
    }

    public boolean startsWith(String[] args, String arg1, String... argsOther) {
        List<ArgsMatcher> expected = Stream.concat(Stream.of(arg1), Stream.of(argsOther))
                .map(ArgsMatcher::exact)
                .toList();

        List<ArgsMatcher> actual = Arrays.stream(args).map(ArgsMatcher::escape).toList()
                .stream().limit(expected.size()).toList();
        return expected.equals(actual);
    }

    public void withRequestTree(Consumer<RequestTree> consumer) {
        // master, request-001
        AtomicReference<String> cControl = new AtomicReference<>();
        FileManagerCacheProxy fm = FileManagerCacheProxy.cachedProxy(new FileManager(conf.getTerm()), cControl);

        Map<String, GitFs> cache = new HashMap<>();
        Map<PosixPath, ConfigVersions> cache2 = new HashMap<>();
        AtomicReference<RequestTree> rts = new AtomicReference<>();

        GitConfigurations cfgs = getGitConfigurations();
        RequestTree rt = getRequestTree(cache, fm, cfgs, cControl, cache2, rts);
        rts.set(rt);
        consumer.accept(rt);
    }

    private RequestTree getRequestTree(Map<String, GitFs> cache, FileManagerCacheProxy fm, GitConfigurations cfgs, AtomicReference<String> cControl, Map<PosixPath, ConfigVersions> cache2, AtomicReference<RequestTree> rts) {
        //fm.go(gitVersions.getLocation());
        return new RequestTree(
                branchName -> cache.computeIfAbsent(branchName, ss ->
                        getGitFsCacheProxy(branchName, fm, cfgs, cControl)
                ),
                gitVersions -> {
                    //fm.go(gitVersions.getLocation());
                    return cache2.computeIfAbsent(gitVersions.getLocation(), (k) -> {
                        ConfigTree ct = new ConfigTree(gitVersions.getDirectory());
                        return new ConfigVersions(gitVersions, ct, rts.get());
                    });
                }, "master", fm);
    }

    private GitConfigurations getGitConfigurations() {
        //String rand = UUID.randomUUID().toString().substring(0, 4);
        return new GitConfigurations() {

            @Override
            public String getTemporaryName(String gitUri1, String branch) {
                //String rand = UUID.randomUUID().toString().substring(0, 4);
                String[] split = gitUri1.replace(":", "://").replace("@", URLEncoder.encode("@")).replace(".git", "").split("/");
                String name = split[split.length - 1];
                return name + (branch != null ? "_" + branch : "") + "_" + "rand";
            }

            @Override
            public Path getHomeTemporaryDir() {
                return conf.getVezuvioLocalHome().climb("tmp").toPath();
            }
        };
    }

    private GitFsCacheProxy getGitFsCacheProxy(
            String branchName,
            FileManagerCacheProxy fm,
            GitConfigurations cfgs,
            AtomicReference<String> cControl
    ) {
        RemoteOrigin remoteOrigin = new RemoteOrigin(
                getConf(ORIGINS_CURRENT),
                fm,
                getAuthStrategy(),
                branchName,
                cfgs,
                WorkingDirectory::new
        ) {
            public Path getRoot() {
                if (this.root == null) {
                    log.debug("Initializing Git root...");
                    return this.recoverState(() -> {
                        String tempDirName = cfgs.getTemporaryName(this.gitUri, branchName);

                        // check if directory exists
                        PosixPath girRoot = PosixPath.of(cfgs.getHomeTemporaryDir())
                                .climb(PosixPath.ofPosix(tempDirName));
                        if (fm.exists(girRoot)) {
                            this.root = girRoot.toPath();
                            return this.root;
                        }

                        return super.getRoot();
                    });
                } else {
                    return this.root;
                }
            }
        };

        GitFsCacheProxy gfs = GitFsCacheProxy.cachedProxy(remoteOrigin, cControl);
        gfs.addListener(fm);
        gfs.setBranch(branchName);
        return gfs;
    }

    private GitAuth getAuthStrategy() {
        String[] authVals = getConf(CREDENTIALS_CURRENT).split(":");
        String authType = authVals[0];
        if (authType.equals("ssh-agent")) {
            return GitAuth.ofSshAgent(authVals[1]);
        } else if (authType.equals("user-token-env")) {
            return AuthStrategy.userAndTokenEnv(authVals[1], authVals[2]);
        }

        throw new IllegalArgumentException("Unknown auth type: " + authType);
    }

}
