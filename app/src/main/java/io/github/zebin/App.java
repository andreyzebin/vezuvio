/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.zebin;

import io.github.andreyzebin.gitSql.config.ConfigTree;
import io.github.andreyzebin.gitSql.config.ConfigVersions;
import io.github.andreyzebin.gitSql.git.LocalSource;
import io.github.zebin.javabash.frontend.FunnyTerminal;
import io.github.zebin.javabash.process.TerminalProcess;
import io.github.zebin.javabash.sandbox.BashUtils;
import io.github.zebin.javabash.sandbox.DirectoryTree;
import io.github.zebin.javabash.sandbox.FileManager;
import io.github.zebin.javabash.sandbox.PosixPath;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.Objects;
import java.util.stream.Stream;

@Slf4j
public class App {


    public static void main(String[] args) {
        FunnyTerminal terminal = new FunnyTerminal(
                new TerminalProcess(BashUtils.runShellForOs(Runtime.getRuntime()))
        );
        FileManager fm = new FileManager(terminal);
        // fm.goUp(); // .../.vezuvio/repository
        // fm.goUp(); // .../.vezuvio

        String resourcesLocation = System.getProperty("VEZUVIO_resources_path");

        fm.makeDir(PosixPath.ofPosix(resourcesLocation));
        fm.go(PosixPath.ofPosix(resourcesLocation));
        PosixPath home = fm.getCurrent();
        PosixPath resources = fm.makeDir(PosixPath.ofPosix("resources"));
        PosixPath mockRepo = PosixPath.ofPosix("/home/andrey/tmp/mock-repo");

        try (LocalSource src = new LocalSource(mockRepo.toPath(), terminal)) {
            fm.go(mockRepo);
            DirectoryTree dt = src.getDirectory();
            ConfigTree ct = new ConfigTree(dt);
            ConfigVersions cf = new ConfigVersions(src, dt, ct);

            String os = terminal.eval("echo $(uname)");
            log.debug("logger.root.level={}", System.getProperty("logger.root.level"));

            if (test(args, "list", "leafs")) {
                ct.getLeafs()
                        .map(PosixPath::toString)
                        .forEach(App::stdoutLine);
            } else if (test(args, "list", "branches")) {
                String branch = getCurrent(fm, terminal, resources, "branch");

            } else if (test(args, "list", "versions")) {
                String branch = getCurrent(fm, terminal, resources, "branch");

                cf.listVersions()
                        .map(ConfigVersions.PropertiesVersion::getVersionHash)
                        .forEach(App::stdoutLine);
            } else if (test(args, "list", "properties")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                ct.getPropertyKeys(leaf).forEach(App::stdoutLine);
            } else if (test(args, "use", /* key */ "branch", /* value */ "*")) {
                setCurrent(args[2], fm, resources, terminal, "branch");

                log.info("Branch {} has been set", args[2]);
            } else if (test(args, "use", /* key */ "leaf", /* value */ "*")) {
                setCurrent(args[2], fm, resources, terminal, "leaf");

                log.info("Leaf {} has been set", args[2]);
            } else if (test(args, "use", "lock")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                ConfigVersions.LeafLock leafLock = cf.tryLock(leaf);
                setCurrent(leafLock.getLockId(), fm, resources, terminal, "lock");

                log.info("Lock has been acquired id = {}, ts = {}",
                        leafLock.getLockId(), leafLock.getObtainedEpochSec());
            } else if (test(args, "use", "version", "*")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                setCurrent(args[2], fm, resources, terminal, "version");
            } else if (test(args, "unuse", "version")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                unSet(fm, resources, "version");
            } else if (test(args, "unuse", "lock")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                String lockId = getCurrent(fm, terminal, resources, "lock");
                cf.unLock(leaf, lockId);
                unSet(fm, resources, "lock");
                log.info("Lock id = {} has been released", lockId);
            } else if (test(args, "commit", "offset",/* newHash */ "*")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                String ver = getCurrent(fm, terminal, resources, "version");

                if (ver != null) {
                    log.error("Must not set version under version use. Please unuse version first...");
                    return;
                }

                String lockId = getCurrent(fm, terminal, resources, "lock");
                if (lockId == null) {
                    log.error("Please acquire lock first");
                    return;
                }

                cf.setVersion(leaf, args[2], lockId);


            } else if (test(args, "set", "property",  /* key */ "*", /* value */ "*")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                String ver = getCurrent(fm, terminal, resources, "version");
                if (ver != null) {
                    log.error("Must not set property under version use. Please unuse version first...");
                    return;
                }

                ct.setProperty(leaf, args[2], args[3]);
                log.info("Property {}#{} has been set", leaf, args[2]);
            } else if (test(args, "get", "property", /* key */ "*")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));
                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                String ver = getCurrent(fm, terminal, resources, "version");
                if (ver != null) {
                    log.debug("Using version {}", ver);
                    stdoutLine(cf.getProperty(ver, leaf, args[2]));
                    return;
                }

                stdoutLine(ct.getProperty(leaf, args[2]));
            } else if (test(args, "get", "offset")) {
                String branch = getCurrent(fm, terminal, resources, "branch");
                PosixPath leaf = PosixPath.ofPosix(getCurrent(fm, terminal, resources, "leaf"));

                log.debug("Current branch is {}", branch);
                log.debug("Current leaf is {}", leaf);

                stdoutLine(cf.getVersion(leaf).getVersionHash());
            } else if (test(args, "shellenv")) {
                terminal.eval(String.format("export VEZUVIO_HOME=\"%s\"", home));
            } else if (test(args, "--version")) {
                stdoutLine(System.getProperty("version"));
            }
        }
    }

    private static void stdoutLine(String line) {
        System.out.println(line);
    }

    private static void setCurrent(String value, FileManager fm, PosixPath resources, FunnyTerminal terminal, String domain) {
        fm.go(resources);
        PosixPath audioPrefix = PosixPath.ofPosix(domain);
        fm.remove(audioPrefix.climb("current"));
        terminal.eval(
                String.format(
                        "ln -s %s %s",
                        fm.makeDir(audioPrefix.climb(PosixPath.ofPosix(value))),
                        audioPrefix.climb("current")
                )
        );
    }

    private static void unSet(FileManager fm, PosixPath resources, String domain) {
        fm.go(resources);
        PosixPath audioPrefix = PosixPath.ofPosix(domain);
        fm.remove(audioPrefix.climb("current"));
    }

    private static String getCurrent(FileManager fm, FunnyTerminal terminal, PosixPath resources, String domain) {
        PosixPath currentPath = resources.climb(domain, "current");
        if (!fm.exists(currentPath)) {
            return null;
        }
        PosixPath audioDevice = PosixPath.ofPosix(
                terminal.eval(String.format("readlink %s", currentPath))
        );

        return audioDevice.relativize(resources.climb(domain)).toString();
    }

    private static boolean test(String[] args, String arg1, String... argsOther) {
        return Stream.concat(Stream.of(arg1), Stream.of(argsOther))
                .map(StringMatcher::exact)
                .toList()
                .equals(Arrays.stream(args).map(StringMatcher::escape).toList());
    }

    public static class StringMatcher {
        public static final StringMatcher ANY = new StringMatcher(true, "*");
        private final boolean isWild;
        private final String template;

        private StringMatcher(boolean isWild, String template) {
            this.isWild = isWild;
            this.template = template;
        }

        public static StringMatcher exact(String s) {
            if (s.equals("*")) {
                return ANY;
            }
            return new StringMatcher(false, s);
        }

        public static StringMatcher escape(String s) {
            return new StringMatcher(false, s);
        }

        @Override
        public boolean equals(Object o) {
            if (o == null || getClass() != o.getClass()) return false;
            StringMatcher that = (StringMatcher) o;
            if (isWild || that.isWild) {
                return true;
            }
            return Objects.equals(template, that.template);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode("*");
        }
    }
}
